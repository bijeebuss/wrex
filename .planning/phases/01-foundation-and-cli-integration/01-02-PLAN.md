---
phase: 01-foundation-and-cli-integration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/claude/types.ts
  - src/lib/claude/ndjson-parser.ts
  - src/lib/claude/process-manager.ts
  - src/routes/api/chat.ts
  - src/routes/index.tsx
autonomous: true

must_haves:
  truths:
    - "Server can spawn a Claude Code CLI process with a prompt and receive streaming JSON events back without dropping or corrupting events"
    - "Server forwards Claude Code streaming events to the browser via SSE in real-time"
    - "Claude Code processes are tracked and cleaned up on disconnect -- no zombie processes accumulate"
    - "NDJSON parser correctly handles chunked data (partial lines buffered, complete lines parsed)"
  artifacts:
    - path: "src/lib/claude/types.ts"
      provides: "TypeScript types for all Claude CLI NDJSON event types"
      exports: ["ClaudeEvent", "SystemEvent", "StreamEvent", "AssistantEvent", "ResultEvent"]
    - path: "src/lib/claude/ndjson-parser.ts"
      provides: "Buffer-based NDJSON line parser for stdout streams"
      exports: ["parseNDJSON"]
    - path: "src/lib/claude/process-manager.ts"
      provides: "Process lifecycle manager for Claude Code CLI"
      exports: ["ClaudeProcessManager"]
    - path: "src/routes/api/chat.ts"
      provides: "SSE streaming endpoint bridging Claude CLI to browser"
      contains: "createServerFileRoute"
  key_links:
    - from: "src/lib/claude/process-manager.ts"
      to: "node:child_process"
      via: "spawn('claude', args)"
      pattern: "spawn.*claude"
    - from: "src/lib/claude/process-manager.ts"
      to: "src/lib/claude/ndjson-parser.ts"
      via: "parseNDJSON import for stdout parsing"
      pattern: "parseNDJSON"
    - from: "src/routes/api/chat.ts"
      to: "src/lib/claude/process-manager.ts"
      via: "ClaudeProcessManager.spawn()"
      pattern: "processManager.*spawn|ClaudeProcessManager"
    - from: "src/routes/api/chat.ts"
      to: "browser"
      via: "SSE Response with text/event-stream"
      pattern: "text/event-stream"
    - from: "src/routes/api/chat.ts"
      to: "src/lib/db/index.ts"
      via: "session creation and message storage"
      pattern: "import.*db"
---

<objective>
Build the Claude Code CLI process manager, NDJSON stream parser, and SSE bridge endpoint that lets the browser send a prompt and receive streaming Claude responses in real-time.

Purpose: This is the core integration layer -- the "plumbing" that connects Claude Code CLI to the web browser. Without it, Wrex is just a static page. After this plan, a browser can POST a prompt, receive token-by-token streaming responses, and the process is cleaned up on disconnect.
Output: Working /api/chat endpoint that spawns Claude Code CLI, parses NDJSON streaming output, and bridges it to the browser via SSE. Process manager tracks active processes and prevents zombies. Basic browser UI to test the full flow.
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-cli-integration/01-RESEARCH.md
@.planning/phases/01-foundation-and-cli-integration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude Code event types, NDJSON parser, and process manager</name>
  <files>
    src/lib/claude/types.ts
    src/lib/claude/ndjson-parser.ts
    src/lib/claude/process-manager.ts
  </files>
  <action>
1. Create `src/lib/claude/types.ts` with TypeScript types for Claude CLI NDJSON events (from RESEARCH.md verified event format):

   Define a discriminated union `ClaudeEvent = SystemEvent | StreamEvent | AssistantEvent | ResultEvent`:

   - `SystemEvent`: type 'system', subtype ('init' | 'hook_started' | 'hook_response'), session_id string, uuid string. The init subtype also carries cwd, tools, model, mcp_servers fields (use `Record<string, unknown>` for these optional fields).
   - `StreamEvent`: type 'stream_event', event object with type ('message_start' | 'content_block_start' | 'content_block_delta' | 'content_block_stop' | 'message_delta' | 'message_stop'), optional index, optional delta (text_delta with text, or input_json_delta with partial_json), optional content_block. Also session_id, parent_tool_use_id (string | null), uuid.
   - `AssistantEvent`: type 'assistant', message object with model, id, role, content array (text blocks and tool_use blocks), stop_reason, usage. Also session_id, parent_tool_use_id, uuid.
   - `ResultEvent`: type 'result', subtype ('success' | 'error'), is_error boolean, duration_ms, num_turns, result string, session_id, total_cost_usd, usage (input_tokens, output_tokens, cache_creation_input_tokens, cache_read_input_tokens), uuid.

   Export all types and the union type.

2. Create `src/lib/claude/ndjson-parser.ts` -- a buffer-based NDJSON line parser:

   Export a function `parseNDJSON(stdout: NodeJS.ReadableStream, onEvent: (event: ClaudeEvent) => void, onError: (error: Error) => void): void`

   Implementation (from RESEARCH.md Pattern 5):
   - Maintain a `buffer` string variable
   - On `data` event: append chunk.toString('utf-8') to buffer, split on '\n', keep last (possibly incomplete) element in buffer, parse each complete line as JSON
   - Skip empty lines (trimmed)
   - On JSON.parse error: call onError with descriptive message including the line content
   - On `end` event: process any remaining buffer content (trim, parse if non-empty)

   CRITICAL: This handles the buffer-splitting pitfall described in RESEARCH.md. Node.js stdout delivers arbitrary-sized chunks -- a single JSON line may be split across chunks, or multiple lines in one chunk. The buffer approach handles both cases.

3. Create `src/lib/claude/process-manager.ts` -- the process lifecycle manager:

   Export a class `ClaudeProcessManager`:

   ```
   private processes: Map<string, ChildProcess>
   ```

   Methods:
   - `spawn(sessionId: string, prompt: string, opts?: { resumeSessionId?: string }): ChildProcess`
     - Build args array: ['-p', prompt, '--output-format', 'stream-json', '--verbose', '--include-partial-messages', '--dangerously-skip-permissions']
     - If opts.resumeSessionId: add ['--resume', opts.resumeSessionId]
     - Spawn 'claude' with args, stdio ['pipe', 'pipe', 'pipe']
     - Store in this.processes map keyed by sessionId
     - On 'exit' event: remove from map
     - Return the ChildProcess

   - `kill(sessionId: string): void`
     - Get process from map
     - If exists and not killed: send SIGTERM
     - Set a 5-second timeout: if still not killed, send SIGKILL
     - Remove from map immediately (don't wait for exit)

   - `killAll(): void`
     - Iterate all entries and call kill() for each

   - `getActive(): string[]`
     - Return array of active session IDs

   - `isActive(sessionId: string): boolean`
     - Check if session exists in map

   Also register server shutdown cleanup:
   - On module load, register `process.on('exit', () => manager.killAll())` and `process.on('SIGTERM', () => { manager.killAll(); process.exit(0) })`
   - Export a singleton instance: `export const processManager = new ClaudeProcessManager()`

   IMPORTANT: Use `{ detached: false }` (the default) for spawn so child processes are part of the same process group and get cleaned up with the parent.
  </action>
  <verify>
Verify TypeScript compiles: `npx tsc --noEmit` (or at minimum verify no import errors by running `node -e "require('./src/lib/claude/types')"` after building). Verify the NDJSON parser handles edge cases by creating a quick test: pipe a multiline string through the parser and check events are emitted correctly. Specifically test: (a) two complete JSON lines in one chunk, (b) one JSON line split across two chunks, (c) empty lines between events.
  </verify>
  <done>TypeScript types cover all 4 Claude CLI event types. NDJSON parser correctly buffers and parses chunked stdout data. Process manager can spawn, track, kill, and killAll Claude processes with SIGTERM/SIGKILL escalation.</done>
</task>

<task type="auto">
  <name>Task 2: Create SSE streaming endpoint and wire up the full browser-to-Claude flow</name>
  <files>
    src/routes/api/chat.ts
    src/routes/index.tsx
  </files>
  <action>
1. Create `src/routes/api/chat.ts` -- SSE streaming server route:

   Use `createServerFileRoute('/api/chat')` with `.methods()` (the NEW TanStack Start API -- NOT createAPIFileRoute).

   POST handler:
   - Parse request JSON body: `{ prompt: string, sessionId?: string }`
   - Validate with zod: prompt must be a non-empty string, sessionId is optional string
   - If no sessionId provided, generate a UUID (use crypto.randomUUID())
   - Create a session record in the database using Drizzle: insert into sessions table with id, status 'active'
   - Create a user message record: insert into messages table with sessionId, role 'user', content = prompt
   - Create a ReadableStream that:
     a. In `start(controller)`:
        - Get the processManager singleton
        - Spawn a Claude process: `processManager.spawn(sessionId, prompt, { resumeSessionId: existingClaudeSessionId })`
        - Set up NDJSON parser on child.stdout with `parseNDJSON()`
        - On each parsed event:
          - Send as SSE: `controller.enqueue(encoder.encode("data: " + JSON.stringify(event) + "\n\n"))`
          - If event is SystemEvent with subtype 'init': extract session_id and update the session's claudeSessionId in the database
          - If event is ResultEvent: extract result text, cost, usage, duration and insert an assistant message into the messages table. Update session status. Then `controller.close()`
        - On parse error: send error SSE event, log to console
        - On child 'exit' with non-zero code: send error SSE event, close controller
        - On child stderr data: log to console (useful for debugging but don't send to client)
     b. In `cancel()`:
        - Kill the Claude process: `processManager.kill(sessionId)`
        - This handles client disconnect (browser closes, navigates away, EventSource closes)
   - Return `new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' } })`

   Error handling:
   - If spawn fails (e.g., 'claude' not found): return 500 with JSON error
   - Wrap the entire handler in try/catch

2. Update `src/routes/index.tsx` to add a minimal but functional chat test UI:

   Replace the placeholder with a simple form that:
   - Has a text input for the prompt and a Send button
   - On submit: POST to `/api/chat` with `{ prompt }` -- but since SSE is one-directional, instead:
     - POST fetch to `/api/chat` with the prompt
     - Read the response as a streaming body using `response.body.getReader()`
     - Parse incoming SSE data lines (split on "data: ", parse JSON)
     - Display events in a scrollable output area:
       - For `stream_event` with `content_block_delta` and `text_delta`: append the text to the output (this gives token-by-token streaming)
       - For `result` events: show completion info (tokens, cost, duration)
       - For errors: show error message in red
   - Show a "Streaming..." indicator while receiving events
   - Show "Connected" / "Disconnected" status

   Keep the UI minimal -- this is a test harness, not the final chat UI (that's Phase 3). Use inline styles or the existing global CSS. No component library needed.

   IMPORTANT: The SSE bridge works like this:
   1. Browser POSTs prompt to /api/chat
   2. Server spawns Claude CLI, returns SSE Response
   3. Browser reads SSE stream using fetch + ReadableStream reader
   4. Each SSE "data:" line contains a JSON Claude event
   5. Browser extracts text deltas and displays them
   6. When stream ends (result event + close), UI shows completion

   This is NOT a standard EventSource pattern (EventSource only does GET). Use fetch() with streaming body reader instead.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Open http://localhost:3000 in browser
3. Type a simple prompt like "What is 2+2?" and click Send
4. Verify: streaming text appears token-by-token in the output area
5. Verify: result event shows token count and duration
6. Check database: `node -e "const db = require('better-sqlite3')('./data/wrex.db'); console.log('sessions:', db.prepare('SELECT * FROM sessions').all()); console.log('messages:', db.prepare('SELECT * FROM messages').all())"` -- should show the session and both user + assistant messages
7. Verify cleanup: after the stream completes, `ps aux | grep claude | grep -v grep` should show no lingering Claude processes
8. Test disconnect: start a long prompt, close the browser tab, verify the Claude process is killed within a few seconds
  </verify>
  <done>POST /api/chat accepts a prompt, spawns Claude Code CLI, parses NDJSON streaming output, and returns SSE to the browser. Browser displays streaming text token-by-token. Sessions and messages are stored in SQLite. Claude processes are tracked and cleaned up on disconnect -- no zombies. The full browser -> server -> Claude Code CLI -> NDJSON -> SSE -> browser pipeline works end-to-end.</done>
</task>

</tasks>

<verification>
1. Full end-to-end flow: type prompt in browser, see streaming response from Claude Code CLI
2. Database has session record with claudeSessionId populated (from Claude's init event)
3. Database has user message (the prompt) and assistant message (the response)
4. `ps aux | grep claude` shows no zombie processes after stream completion
5. Closing browser tab during streaming kills the Claude process within 5 seconds
6. NDJSON parser handles chunked data without corruption (no JSON parse errors in server logs for valid events)
7. SSE events arrive in browser in real-time (not batched at the end)
</verification>

<success_criteria>
- Browser can send a prompt and receive streaming Claude Code responses via SSE
- Token-by-token text streaming visible in the browser
- Sessions and messages persisted to SQLite with proper schema
- Claude Code session_id captured from init event and stored for future --resume
- Process manager tracks all active Claude processes
- Processes killed on client disconnect (SSE cancel)
- Processes killed on server shutdown (SIGTERM handler)
- No zombie Claude processes accumulate
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-cli-integration/01-02-SUMMARY.md`
</output>
