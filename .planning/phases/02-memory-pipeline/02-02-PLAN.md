---
phase: 02-memory-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/db/schema.ts
  - src/lib/memory/indexer.ts
  - src/lib/memory/search.ts
autonomous: true

must_haves:
  truths:
    - "Memory chunks are stored in a sqlite-vec virtual table with 768-dim embeddings and in an FTS5 table for keyword search"
    - "Vector similarity search returns chunks ranked by cosine distance"
    - "FTS5 keyword search returns chunks ranked by BM25"
    - "Hybrid search combines vector and FTS5 results using Reciprocal Rank Fusion and returns a unified ranked list"
    - "Indexing a markdown file chunks it, embeds it, and stores results in both vec and FTS5 tables atomically"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Updated schema with memory_chunks table for Drizzle and SQL for vec0/FTS5 virtual tables"
      contains: "memoryChunks"
    - path: "src/lib/memory/indexer.ts"
      provides: "Orchestrates chunk -> embed -> store pipeline with transactional vec0 + FTS5 insert"
      exports: ["indexFile", "reindexFile", "removeFileIndex"]
    - path: "src/lib/memory/search.ts"
      provides: "Hybrid search combining sqlite-vec KNN and FTS5 BM25 with RRF scoring"
      exports: ["hybridSearch", "vectorSearch", "keywordSearch"]
  key_links:
    - from: "src/lib/memory/indexer.ts"
      to: "src/lib/memory/chunker.ts"
      via: "chunkMarkdown() import"
      pattern: "import.*chunkMarkdown.*from.*chunker"
    - from: "src/lib/memory/indexer.ts"
      to: "src/lib/memory/embedder.ts"
      via: "embed() import for vector generation"
      pattern: "import.*embed.*from.*embedder"
    - from: "src/lib/memory/indexer.ts"
      to: "src/lib/db/index.ts"
      via: "sqlite raw handle for vec0/FTS5 INSERT"
      pattern: "import.*sqlite.*from.*db"
    - from: "src/lib/memory/search.ts"
      to: "src/lib/db/index.ts"
      via: "sqlite raw handle for vec0 MATCH and FTS5 MATCH queries"
      pattern: "import.*sqlite.*from.*db"
    - from: "src/lib/memory/search.ts"
      to: "src/lib/memory/embedder.ts"
      via: "embed(query, 'search_query') for vector search"
      pattern: "embed.*search_query"
---

<objective>
Create SQLite storage tables (sqlite-vec + FTS5) for memory chunks and implement the hybrid search system that combines vector similarity with keyword matching using Reciprocal Rank Fusion.

Purpose: Chunks and embeddings from Plan 01 need persistent storage and a search interface. This plan creates the storage layer and the hybrid search that will be exposed as MCP tools in Plan 03.
Output: Database schema extensions, indexer module, hybrid search module
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-memory-pipeline/02-RESEARCH.md
@.planning/phases/02-memory-pipeline/02-01-SUMMARY.md
@src/lib/db/index.ts
@src/lib/db/schema.ts
@src/lib/memory/types.ts
@src/lib/memory/chunker.ts
@src/lib/memory/embedder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory storage tables (Drizzle + vec0 + FTS5) and the indexer module</name>
  <files>
    src/lib/db/schema.ts
    src/lib/memory/indexer.ts
  </files>
  <action>
1. **Update `src/lib/db/schema.ts`** -- Add a Drizzle table definition for memory_chunks as the content backing table. This table holds chunk metadata and is the authoritative row store. The vec0 and FTS5 virtual tables reference this table's rowid.

   Add a `memoryChunks` table:
   ```typescript
   export const memoryChunks = sqliteTable('memory_chunks', {
     id: integer('id').primaryKey({ autoIncrement: true }),
     filePath: text('file_path').notNull(),
     heading: text('heading').notNull().default(''),
     content: text('content').notNull(),
     startLine: integer('start_line').notNull(),
     endLine: integer('end_line').notNull(),
     embeddingHash: text('embedding_hash'),  // hash to detect if re-embedding needed
     createdAt: integer('created_at', { mode: 'timestamp_ms' })
       .notNull()
       .default(sql`(unixepoch() * 1000)`),
   })
   ```

2. **Create `src/lib/memory/indexer.ts`** -- Orchestrates the full index pipeline.

   On module load (or on first call), ensure the database tables exist by executing raw SQL via the `sqlite` handle from `@/lib/db/index`:

   a. Create the memory_chunks table if it doesn't exist (using `sqlite.exec()`):
      ```sql
      CREATE TABLE IF NOT EXISTS memory_chunks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        file_path TEXT NOT NULL,
        heading TEXT NOT NULL DEFAULT '',
        content TEXT NOT NULL,
        start_line INTEGER NOT NULL,
        end_line INTEGER NOT NULL,
        embedding_hash TEXT,
        created_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000)
      );
      CREATE INDEX IF NOT EXISTS idx_memory_chunks_file ON memory_chunks(file_path);
      ```

   b. Create the sqlite-vec virtual table:
      ```sql
      CREATE VIRTUAL TABLE IF NOT EXISTS vec_memory_chunks USING vec0(
        chunk_id INTEGER PRIMARY KEY,
        embedding float[768]
      );
      ```
      Note: Use minimal vec0 schema with just chunk_id and embedding. Metadata comes from joining back to memory_chunks table. This avoids duplication and keeps the vec0 table lean.

   c. Create the FTS5 virtual table:
      ```sql
      CREATE VIRTUAL TABLE IF NOT EXISTS fts_memory_chunks USING fts5(
        content,
        heading,
        file_path,
        content='memory_chunks',
        content_rowid='id'
      );
      ```
      This is an external-content FTS5 table backed by memory_chunks.

   d. Wrap table creation in a function `ensureTables()` called once at module init. Use a module-level boolean flag to avoid running it multiple times.

3. **Implement `indexFile(filePath: string)`:**
   - Read the file from disk using `fs.readFileSync(filePath, 'utf-8')`
   - Call `chunkMarkdown(content, filePath)` to get chunks
   - For each chunk, call `embed(chunk.content, 'search_document')` to get the embedding vector
   - Wrap the following in a single transaction using `sqlite.transaction()`:
     - INSERT each chunk into memory_chunks table, get back the rowid
     - INSERT the embedding into vec_memory_chunks: `INSERT INTO vec_memory_chunks(chunk_id, embedding) VALUES (?, ?)` with the rowid and `new Float32Array(embedding).buffer`
     - INSERT into fts_memory_chunks: `INSERT INTO fts_memory_chunks(rowid, content, heading, file_path) VALUES (?, ?, ?, ?)`
   - Return the count of chunks indexed
   - IMPORTANT: For FTS5 external content tables, do NOT use application-level triggers. Insert explicitly in the transaction to avoid known better-sqlite3 trigger edge cases.

4. **Implement `removeFileIndex(filePath: string)`:**
   - In a transaction:
     - Get all chunk IDs for the file: `SELECT id FROM memory_chunks WHERE file_path = ?`
     - For each ID, delete from vec_memory_chunks: `DELETE FROM vec_memory_chunks WHERE chunk_id = ?`
     - Delete from FTS5: `INSERT INTO fts_memory_chunks(fts_memory_chunks, rowid, content, heading, file_path) SELECT 'delete', id, content, heading, file_path FROM memory_chunks WHERE file_path = ?` (FTS5 delete command)
     - Delete from memory_chunks: `DELETE FROM memory_chunks WHERE file_path = ?`

5. **Implement `reindexFile(filePath: string)`:**
   - Call `removeFileIndex(filePath)` then `indexFile(filePath)`
   - This is the strategy recommended in the research: full file re-index since memory files are small markdown documents

Export: `indexFile`, `reindexFile`, `removeFileIndex`, `ensureTables`
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Run smoke test: `npx tsx -e "
      import { indexFile, ensureTables } from './src/lib/memory/indexer.ts';
      ensureTables();
      indexFile('./memory/MEMORY.md').then(count => {
        console.log('Chunks indexed:', count);
        process.exit(0);
      });
    "` -- should output a count of 3+ chunks without errors
    - Verify data in DB: `npx tsx -e "
      import { sqlite } from './src/lib/db/index.ts';
      const chunks = sqlite.prepare('SELECT id, file_path, heading FROM memory_chunks').all();
      console.log('memory_chunks:', chunks.length, 'rows');
      const vecs = sqlite.prepare('SELECT count(*) as c FROM vec_memory_chunks').get();
      console.log('vec_memory_chunks:', vecs.c, 'rows');
      const fts = sqlite.prepare('SELECT count(*) as c FROM fts_memory_chunks').get();
      console.log('fts_memory_chunks:', fts.c, 'rows');
      process.exit(0);
    "` -- all three tables should have matching row counts
  </verify>
  <done>
    - memory_chunks table exists with id, file_path, heading, content, start_line, end_line columns
    - vec_memory_chunks vec0 virtual table exists with 768-dim float embedding
    - fts_memory_chunks FTS5 virtual table exists as external content table backed by memory_chunks
    - indexFile() reads markdown, chunks it, embeds chunks, stores all three tables in a transaction
    - removeFileIndex() cleans all three tables for a given file path
    - reindexFile() removes then re-indexes a file
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement hybrid search with vector similarity, FTS5 keyword, and RRF fusion</name>
  <files>
    src/lib/memory/search.ts
  </files>
  <action>
Create `src/lib/memory/search.ts` with three search functions and RRF fusion.

1. **`vectorSearch(query: string, limit: number = 10): Promise<SearchResult[]>`**
   - Call `embed(query, 'search_query')` to get the query vector
   - Convert to Float32Array buffer for sqlite-vec: `new Float32Array(queryVec).buffer`
   - Execute KNN query:
     ```sql
     SELECT chunk_id, distance
     FROM vec_memory_chunks
     WHERE embedding MATCH ?
       AND k = ?
     ORDER BY distance
     ```
   - Join results back to memory_chunks to get full metadata:
     ```sql
     SELECT mc.id, mc.file_path, mc.heading, mc.content, mc.start_line, mc.end_line
     FROM memory_chunks mc WHERE mc.id = ?
     ```
     OR do a single query with subquery/join (but sqlite-vec MATCH queries may not support joins directly -- execute the vec query first, then batch-fetch metadata).
   - Return results with rank (1-indexed position) and distance score

2. **`keywordSearch(query: string, limit: number = 10): SearchResult[]`**
   - Execute FTS5 query:
     ```sql
     SELECT rowid, content, heading, file_path, rank
     FROM fts_memory_chunks
     WHERE fts_memory_chunks MATCH ?
     ORDER BY rank
     LIMIT ?
     ```
   - NOTE: FTS5 MATCH expects a search expression. For natural language queries, wrap the query terms. Simple approach: pass the query as-is (FTS5 handles multi-word queries as implicit AND). If special characters cause issues, quote the query.
   - Join rowid back to memory_chunks for full metadata (start_line, end_line)
   - Return results with rank (1-indexed position) and BM25 score

3. **`hybridSearch(query: string, limit: number = 5): Promise<SearchResult[]>`**
   - Run vectorSearch(query, limit * 2) and keywordSearch(query, limit * 2) -- fetch more from each to get good RRF coverage
   - Apply Reciprocal Rank Fusion (RRF) with k=60:
     ```typescript
     const RRF_K = 60;
     const scores = new Map<number, number>(); // chunk_id -> RRF score

     for (let i = 0; i < vecResults.length; i++) {
       const id = vecResults[i].id;
       scores.set(id, (scores.get(id) ?? 0) + 1 / (i + 1 + RRF_K));
     }
     for (let i = 0; i < ftsResults.length; i++) {
       const id = ftsResults[i].id;
       scores.set(id, (scores.get(id) ?? 0) + 1 / (i + 1 + RRF_K));
     }
     ```
   - Sort by RRF score descending, take top `limit` results
   - For each result, include: id, filePath, heading, content, startLine, endLine, score (RRF), sources (which search methods found it: "vector", "keyword", or "both")
   - Return the fused results

4. **Define `SearchResult` type:**
   ```typescript
   export interface SearchResult {
     id: number;
     filePath: string;
     heading: string;
     content: string;
     startLine: number;
     endLine: number;
     score: number;
     sources: ("vector" | "keyword")[];
   }
   ```

5. **Edge cases:**
   - If vec_memory_chunks is empty (no indexed content), return empty array without error
   - If FTS5 query has no matches, still return vector results (and vice versa)
   - If both are empty, return empty array
   - Handle FTS5 syntax errors gracefully (wrap in try/catch, fall back to vector-only on FTS5 failure)

Do NOT use console.log (module will be used by MCP server). Use console.error for diagnostics.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Run search test (assumes Task 1 indexed memory/MEMORY.md):
      ```
      npx tsx -e "
        import { hybridSearch } from './src/lib/memory/search.ts';
        import { ensureTables } from './src/lib/memory/indexer.ts';
        ensureTables();
        hybridSearch('what is wrex architecture', 3).then(results => {
          console.log('Results:', results.length);
          results.forEach(r => console.log('-', r.heading, '| score:', r.score.toFixed(6), '| sources:', r.sources));
          process.exit(0);
        });
      "
      ```
      Should return 1-3 results with the "Architecture" heading chunk scoring highest.
    - Test keyword-only search:
      ```
      npx tsx -e "
        import { keywordSearch } from './src/lib/memory/search.ts';
        import { ensureTables } from './src/lib/memory/indexer.ts';
        ensureTables();
        const results = keywordSearch('sqlite', 3);
        console.log('FTS results:', results.length);
        results.forEach(r => console.log('-', r.heading, '| score:', r.score));
        process.exit(0);
      "
      ```
      Should find chunks mentioning "sqlite".
  </verify>
  <done>
    - vectorSearch() returns chunks ranked by cosine distance from sqlite-vec
    - keywordSearch() returns chunks ranked by BM25 from FTS5
    - hybridSearch() combines both via RRF (k=60) and returns unified ranked results
    - Each SearchResult includes id, filePath, heading, content, startLine, endLine, score, sources
    - Hybrid search for "wrex architecture" returns the Architecture chunk ranked highest
    - Empty index returns empty array without errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. All three database tables created: memory_chunks, vec_memory_chunks, fts_memory_chunks
3. indexFile('./memory/MEMORY.md') stores chunks in all three tables with matching row counts
4. hybridSearch('architecture') returns relevant results with RRF scores
5. keywordSearch('sqlite') returns FTS5 results
6. vectorSearch('what is this project') returns semantically relevant results
7. removeFileIndex cleans all three tables for a file
8. reindexFile removes and re-indexes cleanly
</verification>

<success_criteria>
- Memory chunks are stored in sqlite-vec (vectors) and FTS5 (text) simultaneously
- Hybrid search returns ranked results combining both methods via RRF
- Indexing is transactional -- all three tables updated atomically
- Search works correctly with the seed memory/MEMORY.md data
</success_criteria>

<output>
After completion, create `.planning/phases/02-memory-pipeline/02-02-SUMMARY.md`
</output>
