---
phase: 02-memory-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/mcp-server.ts
  - .mcp.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "MCP server starts via stdio transport and registers memory_search, memory_get, and memory_write tools"
    - "memory_search accepts a natural language query and returns ranked snippets with file paths and scores"
    - "memory_get reads a specific memory file by path with optional line range"
    - "memory_write appends or overwrites content in a memory file and re-indexes it so new content becomes searchable"
    - "Claude Code can discover and call the MCP tools when configured via .mcp.json"
  artifacts:
    - path: "src/mcp-server.ts"
      provides: "Standalone MCP server process with stdio transport and three memory tools"
      exports: ["main"]
      min_lines: 80
    - path: ".mcp.json"
      provides: "Claude Code MCP server configuration pointing to wrex-memory"
      contains: "wrex-memory"
    - path: "package.json"
      provides: "Updated scripts with mcp:dev command"
      contains: "mcp:dev"
  key_links:
    - from: "src/mcp-server.ts"
      to: "src/lib/memory/search.ts"
      via: "hybridSearch import for memory_search tool"
      pattern: "import.*hybridSearch.*from.*search"
    - from: "src/mcp-server.ts"
      to: "src/lib/memory/indexer.ts"
      via: "reindexFile import for memory_write tool"
      pattern: "import.*reindexFile.*from.*indexer"
    - from: "src/mcp-server.ts"
      to: "@modelcontextprotocol/sdk"
      via: "McpServer + StdioServerTransport"
      pattern: "McpServer|StdioServerTransport"
    - from: ".mcp.json"
      to: "src/mcp-server.ts"
      via: "stdio command pointing to tsx runner"
      pattern: "mcp-server"
---

<objective>
Create the MCP server that exposes memory_search, memory_get, and memory_write as tools over stdio, and configure it for Claude Code discovery.

Purpose: This is the interface between Claude Code and the memory system. When Claude Code runs with this MCP config, it can search memories, read specific files, and persist new information -- completing the full memory pipeline.
Output: MCP server entry point, .mcp.json config, updated package.json
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-memory-pipeline/02-RESEARCH.md
@.planning/phases/02-memory-pipeline/02-01-SUMMARY.md
@.planning/phases/02-memory-pipeline/02-02-SUMMARY.md
@src/lib/memory/types.ts
@src/lib/memory/search.ts
@src/lib/memory/indexer.ts
@src/lib/memory/embedder.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP server with memory_search, memory_get, and memory_write tools</name>
  <files>
    src/mcp-server.ts
  </files>
  <action>
Create `src/mcp-server.ts` -- standalone MCP server entry point.

CRITICAL: This is a stdio-based MCP server. **NEVER use console.log()** anywhere in this file or any code it imports at the top level. All stdout writes would corrupt the JSON-RPC transport. Use console.error() for all logging/diagnostics.

1. **Imports and setup:**
   ```typescript
   import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
   import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
   import { z } from "zod";
   import { readFileSync, writeFileSync, mkdirSync, existsSync } from "node:fs";
   import { dirname, join, resolve } from "node:path";
   import { hybridSearch } from "./lib/memory/search.js";
   import { reindexFile, ensureTables } from "./lib/memory/indexer.js";
   ```

   Note: Use `.js` extensions in imports (ESM resolution). The tsx runner will resolve them correctly.

2. **Define memory directory constant:**
   ```typescript
   const MEMORY_DIR = resolve(process.cwd(), "memory");
   ```

3. **Create McpServer instance:**
   ```typescript
   const server = new McpServer({
     name: "wrex-memory",
     version: "0.1.0",
   });
   ```

4. **Register `memory_search` tool:**
   - Input schema: `{ query: z.string().describe("Natural language search query"), limit: z.number().optional().default(5).describe("Maximum number of results to return") }`
   - Handler: Call `hybridSearch(query, limit)`
   - Format results as readable text, not raw JSON. For each result include: heading, file path, line range, relevance score, sources (vector/keyword/both), and a content preview (first 200 chars)
   - Return `{ content: [{ type: "text", text: formattedResults }] }`
   - If no results, return a message saying "No relevant memories found for: {query}"

5. **Register `memory_get` tool:**
   - Input schema: `{ path: z.string().describe("Path to memory file relative to memory/ directory"), startLine: z.number().optional().describe("Start line number (1-indexed, inclusive)"), endLine: z.number().optional().describe("End line number (1-indexed, inclusive)") }`
   - Handler:
     - Resolve the full path: `join(MEMORY_DIR, path)`
     - SECURITY: Validate the resolved path starts with MEMORY_DIR (prevent path traversal)
     - Read the file with `readFileSync`
     - If startLine/endLine provided, extract only those lines (split on newline, slice, rejoin)
     - Return `{ content: [{ type: "text", text: fileContent }] }`
     - If file doesn't exist, return an error message (not a throw -- return it as text content so Claude sees it)

6. **Register `memory_write` tool:**
   - Input schema: `{ path: z.string().describe("Path to memory file relative to memory/ directory"), content: z.string().describe("Content to write (markdown format)"), mode: z.enum(["append", "overwrite"]).optional().default("append").describe("append adds to end of file, overwrite replaces entire file") }`
   - Handler:
     - Resolve the full path: `join(MEMORY_DIR, path)`
     - SECURITY: Validate the resolved path starts with MEMORY_DIR
     - If mode is "append": read existing content (or empty string if file doesn't exist), append a newline + new content, write back
     - If mode is "overwrite": write the content directly
     - Ensure parent directories exist: `mkdirSync(dirname(fullPath), { recursive: true })`
     - After writing, call `reindexFile(fullPath)` to re-chunk, re-embed, and update indexes
     - Return `{ content: [{ type: "text", text: "Written to memory/${path} and re-indexed (N chunks)." }] }` where N is the chunk count from reindex

7. **Main function:**
   ```typescript
   async function main() {
     ensureTables();  // ensure DB tables exist before serving
     const transport = new StdioServerTransport();
     await server.connect(transport);
     console.error("wrex-memory MCP server running on stdio");
   }

   main().catch((err) => {
     console.error("Fatal:", err);
     process.exit(1);
   });
   ```

8. **Graceful shutdown:** Handle SIGINT and SIGTERM to call `disposeEmbedder()` and close the server cleanly.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Test MCP server starts and responds to protocol: Run `echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1.0"}}}' | npx tsx src/mcp-server.ts 2>/dev/null` -- should output a JSON-RPC response with server capabilities (may need to also send an `initialized` notification and `tools/list` request to see the tools)
    - Verify no console.log in the codebase path: Search for console.log in src/mcp-server.ts and src/lib/memory/ -- should find none
  </verify>
  <done>
    - MCP server registers three tools: memory_search, memory_get, memory_write
    - memory_search calls hybridSearch and returns formatted results
    - memory_get reads files with path traversal protection
    - memory_write persists content and triggers re-indexing
    - Server communicates over stdio using StdioServerTransport
    - No console.log anywhere in the server or its imported memory modules
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure MCP for Claude Code and add convenience scripts</name>
  <files>
    .mcp.json
    package.json
  </files>
  <action>
1. **Create `.mcp.json`** in the project root for Claude Code MCP discovery:
   ```json
   {
     "mcpServers": {
       "wrex-memory": {
         "type": "stdio",
         "command": "npx",
         "args": ["tsx", "src/mcp-server.ts"]
       }
     }
   }
   ```
   This tells Claude Code to spawn the MCP server using tsx (which handles TypeScript + ESM). The server runs as a child process communicating over stdio.

   Note: Using `npx tsx` rather than `node ./dist/mcp-server.js` because we don't have a build step for the MCP server yet. This works for development. In production, it would be compiled first.

2. **Update `package.json`** -- add scripts for MCP server development and memory management:
   ```json
   "mcp:dev": "npx tsx src/mcp-server.ts",
   "memory:index": "npx tsx -e \"import { indexFile, ensureTables } from './src/lib/memory/indexer.ts'; import { readdirSync } from 'fs'; import { join } from 'path'; ensureTables(); const dir = './memory'; const files = readdirSync(dir).filter(f => f.endsWith('.md')); Promise.all(files.map(f => indexFile(join(dir, f)))).then(counts => { console.log('Indexed', counts.reduce((a,b)=>a+b,0), 'chunks from', files.length, 'files'); process.exit(0); });\""
   ```

   The `memory:index` script indexes all markdown files in the memory/ directory. This is a one-time bootstrap command.

3. **Add to `.gitignore`** (if not already present):
   ```
   models/
   ```
   The GGUF model files are large (~140 MiB) and should not be committed to git.

4. **Verify end-to-end by running the index command:**
   Run `npm run memory:index` to index the seed memory/MEMORY.md file. This proves the full pipeline: read markdown -> chunk -> embed -> store in vec0 + FTS5.
  </action>
  <verify>
    - `.mcp.json` exists in project root with wrex-memory server config
    - `npm run mcp:dev` starts the MCP server (sends output to stderr, stdin awaits JSON-RPC)
    - `npm run memory:index` indexes memory files and prints chunk count
    - `models/` is in .gitignore
    - Full pipeline test: After running memory:index, test search by running:
      ```
      npx tsx -e "
        import { hybridSearch } from './src/lib/memory/search.ts';
        import { ensureTables } from './src/lib/memory/indexer.ts';
        ensureTables();
        hybridSearch('what decisions were made', 3).then(r => {
          r.forEach(x => console.log(x.heading, x.score.toFixed(4), x.sources));
          process.exit(0);
        });
      "
      ```
  </verify>
  <done>
    - .mcp.json configures wrex-memory server for Claude Code discovery via stdio
    - package.json has mcp:dev and memory:index scripts
    - models/ is gitignored
    - Full pipeline verified: markdown -> chunk -> embed -> store -> hybrid search returns results
    - Claude Code can be configured to use the wrex-memory MCP server
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. MCP server starts without errors: `npm run mcp:dev` (check stderr for startup message)
3. No console.log in MCP server code path (grep confirms)
4. .mcp.json exists with correct config
5. memory:index script works end-to-end
6. All three MCP tools are registered (initialize + tools/list returns 3 tools)
7. Path traversal protection works (memory_get rejects paths outside memory/)
8. memory_write + reindex cycle: write new content, search for it, find it
</verification>

<success_criteria>
- MCP server runs over stdio and exposes memory_search, memory_get, memory_write
- memory_search returns ranked snippets with file paths and scores via hybrid search
- memory_get reads specific file content with path safety
- memory_write persists content and re-indexes so it becomes immediately searchable
- Claude Code can discover the tools via .mcp.json configuration
</success_criteria>

<output>
After completion, create `.planning/phases/02-memory-pipeline/02-03-SUMMARY.md`
</output>
