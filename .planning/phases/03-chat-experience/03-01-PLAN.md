---
phase: 03-chat-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vite.config.ts
  - src/styles/global.css
  - src/routes/__root.tsx
  - src/routes/index.tsx
  - src/types/chat.ts
  - src/hooks/useChat.ts
  - src/hooks/useAutoScroll.ts
  - src/components/chat/ChatMessage.tsx
  - src/components/chat/ChatInput.tsx
  - src/components/chat/ChatMessages.tsx
  - src/components/chat/ErrorBubble.tsx
  - src/components/chat/ToolBlock.tsx
  - src/components/ui/LoadingIndicator.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can type a message in an auto-expanding textarea, press Enter to send, and Shift+Enter for newline"
    - "User sees Claude's response stream token-by-token in a chat bubble with markdown rendering and syntax-highlighted code blocks with copy button"
    - "User sees a loading indicator (pulsing dots) between sending a message and first response token"
    - "Chat auto-scrolls during streaming but stops when the top of the newest assistant message reaches the top of the viewport"
    - "User can manually scroll up during streaming without auto-scroll fighting them"
    - "User sees inline error bubbles with a retry button when something fails"
    - "Stop button is visible during streaming to abort the response"
    - "User can type a new message while Claude is streaming -- it queues and sends when current response completes"
  artifacts:
    - path: "src/hooks/useChat.ts"
      provides: "SSE streaming hook with message accumulation, queue, abort, retry"
      exports: ["useChat"]
    - path: "src/hooks/useAutoScroll.ts"
      provides: "Smart auto-scroll with IntersectionObserver and manual scroll detection"
      exports: ["useAutoScroll"]
    - path: "src/components/chat/ChatMessage.tsx"
      provides: "Chat bubble with streamdown markdown rendering"
    - path: "src/components/chat/ChatInput.tsx"
      provides: "Auto-expanding textarea with send/stop buttons"
    - path: "src/components/chat/ChatMessages.tsx"
      provides: "Scrollable message list container with auto-scroll wiring"
    - path: "src/types/chat.ts"
      provides: "Shared chat UI types"
  key_links:
    - from: "src/hooks/useChat.ts"
      to: "/api/chat"
      via: "fetch POST with SSE parsing"
      pattern: "fetch.*api/chat"
    - from: "src/components/chat/ChatMessages.tsx"
      to: "src/hooks/useAutoScroll.ts"
      via: "IntersectionObserver on latest message"
      pattern: "useAutoScroll"
    - from: "src/components/chat/ChatMessage.tsx"
      to: "streamdown"
      via: "Streamdown component for assistant messages"
      pattern: "Streamdown"
---

<objective>
Build the streaming chat interface with proper message bubbles, markdown rendering, auto-scroll, loading states, error handling, and message queuing. This replaces the basic test UI from Phase 1 with the production chat experience.

Purpose: This is the core interaction surface -- users type messages and see Claude's responses stream in real-time with rich formatting. Everything else (session management, memory) layers on top of this.

Output: A working chat page with bubble-style messages, streaming markdown with syntax highlighting, auto-expanding input, smart auto-scroll, and error handling. Ready for session routing to be layered on top in Plan 03-02.
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-chat-experience/03-RESEARCH.md
@.planning/phases/01-foundation-and-cli-integration/01-02-SUMMARY.md

Key existing files to reference:
@src/routes/index.tsx (current test UI -- SSE parsing pattern to extract into hook)
@src/routes/__root.tsx (needs color-scheme meta tag, Tailwind CSS link)
@src/lib/claude/types.ts (NDJSON event types for useChat hook)
@vite.config.ts (add Tailwind plugin)
@src/styles/global.css (replace with Tailwind import + theme variables)
@package.json (add new dependencies)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure Tailwind CSS v4 with streamdown</name>
  <files>
    package.json
    vite.config.ts
    src/styles/global.css
    src/routes/__root.tsx
    src/types/chat.ts
  </files>
  <action>
1. Install dependencies:
   ```bash
   npm install streamdown @streamdown/code @tailwindcss/vite tailwindcss react-textarea-autosize clsx
   ```

2. Update `vite.config.ts` -- add Tailwind CSS Vite plugin BEFORE tanstackStart:
   ```typescript
   import tailwindcss from '@tailwindcss/vite'
   // plugins array: [tsconfigPaths(), tailwindcss(), tanstackStart()]
   ```

3. Replace `src/styles/global.css` with Tailwind setup:
   ```css
   @import "tailwindcss";
   @source "../node_modules/streamdown/dist/*.js";
   @import "streamdown/styles.css";

   @theme {
     --color-user-bubble: #3b5998;
     --color-claude-bubble: #2d3748;
     --color-user-bubble-light: #e3effd;
     --color-claude-bubble-light: #f0f4f8;
   }
   ```
   The `@source` directive tells Tailwind to scan streamdown's compiled output for class names.
   Choose warm, friendly colors per user decision. User bubble: a warm blue (#3b5998 dark, #e3effd light). Claude bubble: a warm slate (#2d3748 dark, #f0f4f8 light).

4. Update `src/routes/__root.tsx`:
   - Add `{ name: 'color-scheme', content: 'light dark' }` to head meta to prevent SSR dark mode flash
   - Add `className="bg-white dark:bg-gray-950 text-gray-900 dark:text-gray-100 min-h-screen"` to the `<body>` tag

5. Create `src/types/chat.ts` with shared UI types:
   ```typescript
   export interface ChatMessage {
     id: string
     role: 'user' | 'assistant'
     content: string
     isStreaming?: boolean
     toolCalls?: ToolCallState[]
     error?: string
   }

   export interface ToolCallState {
     id: string
     name: string
     input: string
     status: 'running' | 'complete'
   }

   export type ChatStatus = 'idle' | 'streaming' | 'done' | 'error'

   export interface MemorySnippet {
     filePath: string
     heading: string
     content: string
     startLine: number
     endLine: number
   }
   ```
  </action>
  <verify>
  Run `npx vite build --mode development 2>&1 | head -30` to verify Tailwind plugin loads and CSS compiles without errors. Check that streamdown and @streamdown/code are in node_modules.
  </verify>
  <done>
  Tailwind v4 compiles CSS via Vite plugin, streamdown styles are included, dark mode works via prefers-color-scheme without JS flash, shared chat types are defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build chat components, hooks, and streaming page</name>
  <files>
    src/hooks/useChat.ts
    src/hooks/useAutoScroll.ts
    src/components/chat/ChatMessage.tsx
    src/components/chat/ChatInput.tsx
    src/components/chat/ChatMessages.tsx
    src/components/chat/ErrorBubble.tsx
    src/components/chat/ToolBlock.tsx
    src/components/ui/LoadingIndicator.tsx
    src/routes/index.tsx
  </files>
  <action>
**Create `src/hooks/useChat.ts`:**
Extract and enhance the SSE parsing pattern from the current `src/routes/index.tsx`. The hook must:
- Accept `{ sessionId?: string, onSessionCreated?: (id: string) => void, initialMessages?: ChatMessage[] }`
- Maintain `messages: ChatMessage[]` in state (initialized from initialMessages)
- `sendMessage(text)`: if status === 'streaming', push to queue and add user message to UI immediately; otherwise add user message and call startStream
- `startStream(text)`: set status='streaming', create AbortController, add empty assistant message with `isStreaming: true`, POST to /api/chat with sessionId, parse SSE events:
  - `type === 'session'`: capture sessionId, call onSessionCreated
  - `type === 'stream_event'` with `content_block_delta` + `text_delta`: append delta.text to last assistant message content
  - `type === 'stream_event'` with `content_block_start` + `content_block.type === 'tool_use'`: add ToolCallState with name and id, status 'running'
  - `type === 'stream_event'` with `content_block_delta` + `input_json_delta`: append to tool call input
  - `type === 'stream_event'` with `content_block_stop`: if current block was tool_use, mark tool as 'complete'
  - `type === 'result'`: set status='done', mark assistant message isStreaming=false, check queue and send next
  - `type === 'error'`: set error on last assistant message, set status='error'
- `stopStreaming()`: abort controller, set status='idle'
- `retryLast()`: find last user message, remove the errored assistant message, re-send
- On unmount: abort any active controller
- Return `{ messages, status, error, sendMessage, stopStreaming, retryLast }`
- Track content block index to know when tool_use blocks start/stop (increment on content_block_start, use index to match content_block_stop)

**Create `src/hooks/useAutoScroll.ts`:**
- Accept ref to the scrollable container div
- Track `isAutoScrollEnabled` (boolean, default true)
- Track `showScrollButton` (boolean, default false)
- On new assistant message start (messages array length changes with new assistant message): scroll the message top into view, set isAutoScrollEnabled=true
- Use IntersectionObserver on the top edge of the latest assistant message (a sentinel div at the top of the message). When it exits the viewport (not intersecting at top), stop auto-scrolling (set isAutoScrollEnabled=false)
- Listen for scroll events on container: if user scrolls up (scrollTop decreases while streaming), set isAutoScrollEnabled=false (manual override)
- When isAutoScrollEnabled and streaming: on each message content change, call scrollTop = scrollHeight (keep at bottom) BUT only while the message top is still visible
- `showScrollButton` = true when scrollTop + clientHeight < scrollHeight - 100
- `scrollToBottom()`: scroll container to bottom, re-enable auto-scroll
- Return `{ showScrollButton, scrollToBottom, latestMessageRef }`

**Create `src/components/ui/LoadingIndicator.tsx`:**
Three pulsing dots inside a bubble-shaped container. Use Tailwind animate-pulse with staggered delays:
```tsx
function LoadingIndicator() {
  return (
    <div className="flex justify-start mb-4">
      <div className="rounded-2xl px-5 py-3 bg-(--color-claude-bubble) dark:bg-(--color-claude-bubble)">
        <div className="flex gap-1.5">
          <span className="w-2 h-2 rounded-full bg-gray-400 animate-bounce [animation-delay:0ms]" />
          <span className="w-2 h-2 rounded-full bg-gray-400 animate-bounce [animation-delay:150ms]" />
          <span className="w-2 h-2 rounded-full bg-gray-400 animate-bounce [animation-delay:300ms]" />
        </div>
      </div>
    </div>
  )
}
```

**Create `src/components/chat/ToolBlock.tsx`:**
Collapsible block for tool calls, styled like GitHub PR check blocks per user decision:
- Collapsed by default: shows icon + tool name + status (spinner if running, checkmark if complete)
- Click to expand: shows tool input JSON formatted
- Use `<details>` + `<summary>` for native collapse behavior, styled with Tailwind
- Spinner: a small animated spinner SVG when status='running'
- Tool name displayed as human-readable (e.g., "memory_search" -> "Searched memory", "memory_get" -> "Read memory", "memory_write" -> "Wrote to memory", fallback to raw name)

**Create `src/components/chat/ErrorBubble.tsx`:**
Error message in a special red-tinted bubble with retry button:
```tsx
function ErrorBubble({ message, onRetry }: { message: string; onRetry: () => void }) {
  return (
    <div className="flex justify-start mb-4">
      <div className="max-w-[80%] rounded-2xl px-4 py-3 bg-red-900/30 dark:bg-red-900/30 border border-red-500/30">
        <p className="text-red-300 text-sm">{message}</p>
        <button onClick={onRetry} className="mt-2 text-sm text-red-400 hover:text-red-300 underline">
          Retry
        </button>
      </div>
    </div>
  )
}
```

**Create `src/components/chat/ChatMessage.tsx`:**
- Props: `{ message: ChatMessage }` from types/chat.ts
- User messages: right-aligned bubble with `bg-(--color-user-bubble)` dark / `bg-(--color-user-bubble-light)` light, white text dark / dark text light, rounded-2xl, max-w-[80%], whitespace-pre-wrap
- Assistant messages: left-aligned bubble with `bg-(--color-claude-bubble)` dark / `bg-(--color-claude-bubble-light)` light, rounded-2xl, max-w-[80%]
- For assistant messages: use `<Streamdown plugins={{ code }} isAnimating={message.isStreaming}>{message.content}</Streamdown>` for markdown rendering
- Import streamdown: `import { Streamdown } from 'streamdown'` and `import { code } from '@streamdown/code'`
- If message has toolCalls, render ToolBlock components between/after the text content
- If message has error, render ErrorBubble instead of normal content
- Use `React.memo` to prevent re-renders of non-streaming messages
- Font size: 15px for messages (text-[15px]), 13px for code blocks (handled by streamdown)

**Create `src/components/chat/ChatInput.tsx`:**
- Uses `react-textarea-autosize` for auto-expanding textarea
- Props: `{ onSend: (text: string) => void, onStop: () => void, isStreaming: boolean, disabled?: boolean }`
- Single line that grows as you type (minRows=1, maxRows=6)
- Enter to send (calls onSend with trimmed text, clears input), Shift+Enter for newline
- Send button (arrow icon or "Send" text) when not streaming, Stop button (square icon or "Stop") when streaming
- Input is NEVER disabled per user decision -- user can type ahead while streaming
- Warm, rounded styling: rounded-2xl border, focus ring
- Dark mode: dark background input field

**Create `src/components/chat/ChatMessages.tsx`:**
- Props: `{ messages: ChatMessage[], status: ChatStatus, onRetry: () => void }`
- Scrollable container (flex-1, overflow-y-auto)
- Maps over messages rendering ChatMessage for each
- Shows LoadingIndicator when status='streaming' and last message has no content yet (waiting for first token)
- Wires useAutoScroll hook to the container
- Places a sentinel ref at the top of the latest assistant message for IntersectionObserver
- Shows "scroll to bottom" button when showScrollButton is true (fixed position at bottom-right of chat area, circular button with down arrow)

**Replace `src/routes/index.tsx`:**
Remove the entire existing test UI. Replace with a simple chat page that:
- Uses `useChat` hook (no sessionId initially -- new chat)
- Renders `<ChatMessages>` and `<ChatInput>`
- On session created (from SSE): could navigate to session route later, for now just track it
- Full height layout: flex flex-col h-screen, ChatMessages takes flex-1, ChatInput at bottom
- Max width container: max-w-3xl mx-auto for comfortable reading width
- This is a temporary arrangement -- Plan 03-02 will restructure into layout routes

**Important implementation notes:**
- Tailwind v4 uses `bg-(--color-name)` syntax for CSS variables (parentheses, not square brackets like v3)
- streamdown import may need `'streamdown/react'` -- check the actual export. Research says `import { Streamdown } from 'streamdown'`
- The useChat hook should batch rapid state updates to avoid re-render thrashing: consider accumulating text deltas and flushing via requestAnimationFrame
- All components use `clsx` for conditional class joining
  </action>
  <verify>
  Run `npx vite dev` and verify:
  1. The page loads without errors in the browser console
  2. The chat input renders as an auto-expanding textarea
  3. Sending a message shows a user bubble on the right and a loading indicator
  4. TypeScript compilation: `npx tsc --noEmit` passes
  </verify>
  <done>
  Chat interface renders with bubble-style messages (user right, assistant left), streaming markdown with syntax highlighting via streamdown, auto-expanding textarea input (Enter to send, Shift+Enter newline), loading indicator between send and first token, inline error bubbles with retry, smart auto-scroll that stops when message top hits viewport top, stop button during streaming, and message queuing while streaming. The existing test UI in index.tsx is fully replaced.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- TypeScript compiles without errors
2. `npx vite dev` -- Dev server starts, page loads in browser
3. Chat input auto-expands when typing multiple lines
4. Enter sends message, Shift+Enter creates newline
5. User messages appear in right-aligned colored bubbles
6. Loading dots appear while waiting for Claude's first token
7. Dark mode applies automatically based on system preference without flash
</verification>

<success_criteria>
- Chat bubble UI renders with user messages on right, assistant on left, in warm colored bubbles
- Token-by-token streaming works via useChat hook connected to /api/chat SSE endpoint
- Streamdown renders markdown with syntax-highlighted code blocks and copy button
- Auto-scroll behavior: scrolls new message into view, stops when message top hits viewport top
- Input remains active during streaming (message queuing works)
- Stop button aborts streaming
- Error bubbles appear inline with retry button
- Loading indicator shows between send and first token
- Dark mode via prefers-color-scheme, no flash on load
</success_criteria>

<output>
After completion, create `.planning/phases/03-chat-experience/03-01-SUMMARY.md`
</output>
